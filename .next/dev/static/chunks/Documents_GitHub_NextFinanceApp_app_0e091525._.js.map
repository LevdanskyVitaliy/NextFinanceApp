{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/vitaliylevdansky/Documents/GitHub/NextFinanceApp/app/services/logic.ts"],"sourcesContent":["\n// export type Transaction = {\n//   id?: string | number;\n//   amount: number;\n//   date: string;\n//   category: string;\n//   description: string;\n//   type: \"expense\" | \"income\" | string;\n// };\n\n// export type SortOptions = {\n//   field: string | null;\n//   direction: \"desc\" | \"asc\" | null;\n// };\n\n// interface Params {\n//   page?: number;\n//   limit?: number;\n//   filters?: Record<string, any>;\n//   sort?: SortOptions;\n// }\n\n// export type Category = {\n//   id: string | number;\n//   name: string;\n// };\n\n// class Api {\n//   #baseURL = \"http://localhost:3000\";\n  \n \n//   #categoriesCache: Category[] | null = null;\n\n//   /**\n//    * Internal fetch wrapper that handles errors consistently\n//    * \n//    * @param path - API endpoint path (e.g., \"/transactions\" or \"/categories\")\n//    * @param options - Standard fetch options (method, body, headers, etc.)\n//    * @returns Parsed JSON response\n//    * @throws Error if HTTP response is not ok (status >= 400)\n//    */\n//   async #fetch(path: string, options?: RequestInit): Promise<any> {\n    \n//     const response = await fetch(this.#baseURL + path, options);\n    \n//     if (!response.ok) {\n      \n//       const text = await response.text();\n//       throw new Error(`HTTP error ${response.status}: ${text}`);\n//     }\n\n//     return await response.json();\n//   }\n\n  \n//   getAllCategories = async (): Promise<Category[]> => {\n    \n//     if (!this.#categoriesCache) {\n//       const categories = await this.#fetch(\"/categories\");\n//       this.#categoriesCache = Array.isArray(categories) ? categories : [];\n//     }\n//     return this.#categoriesCache;\n//   };\n\n  \n//   createTransaction = (transaction: Transaction): Promise<Transaction> => {\n\n//     this.#categoriesCache = null;\n    \n//     return this.#fetch(\"/transactions\", {\n//       method: \"POST\",\n//       body: JSON.stringify(transaction),\n//       headers: {\n//         \"Content-Type\": \"application/json\",\n//       },\n//     });\n//   };\n\n\n//   deleteTransaction = (id: number | string): Promise<void> =>\n//     this.#fetch(`/transactions/${id}`, { method: \"DELETE\" });\n\n \n//   updateTransaction = (\n//     id: number | string,\n//     updates: Partial<Transaction>\n//   ): Promise<Transaction> =>\n//     this.#fetch(`/transactions/${id}`, {\n//       method: \"PATCH\",\n//       headers: {\n//         \"Content-Type\": \"application/json\",\n//       },\n//       body: JSON.stringify(updates),\n//     });\n\n \n//   getTransactionById = async (id: string | number): Promise<Transaction> => {\n//     const response = await fetch(`${this.#baseURL}/transactions/${id}`);\n\n//     if (!response.ok) {\n//       // Provide user-friendly error for 404\n//       if (response.status === 404) {\n//         throw new Error(`Transaction with id ${id} not found`);\n//       }\n//       const text = await response.text();\n//       throw new Error(`HTTP error ${response.status}: ${text}`);\n//     }\n\n//     return await response.json();\n//   };\n\n  \n//   async getTransactions(params: Params = {}): Promise<Transaction> {\n    \n//     const {\n//       page = 1,\n//       limit = 10,\n//       filters = {},\n//       sort = { field: \"\", direction: \"desc\" },\n//     } = params;\n    \n    \n//     const query = new URLSearchParams({\n//       _page: page.toString(),\n//       _per_page: limit.toString(),\n//       ...filters, // Spread filters as query params (e.g., { category: \"5\" } â†’ ?category=5)\n//     });\n\n   \n//     if (sort.field) {\n//       query.set(\n//         \"_sort\",\n//         sort.direction === \"desc\" ? `-${sort.field}` : sort.field\n//       );\n//     }\n\n//     const result = await this.#fetch(`/transactions?${query.toString()}`);\n//     return { ...result, currentPage: page };\n//   }\n// }\n\n// export default Api;\n\n\nexport type Transaction = {\n  id?: string | number | undefined;\n  amount: number;\n  date: string;\n  category: string;\n  description: string;\n  type: \"expense\" | \"income\" | string;\n};\n\nexport type SortOptions = {\n  field: string | null;\n  direction: \"desc\" | \"asc\" | null;\n};\n\nexport type Category = {\n  id: string | number;\n  name: string;\n};\n\ninterface Params {\n  page?: number | undefined;\n  limit?: number | undefined;\n  filters?: Record<string, any>;\n  sort?: SortOptions;\n}\n\n\nexport interface PaginatedTransactions {\n  data: Transaction[];       \n  pages: number | undefined;             // Total pages\n  items: number | undefined;             // Total items count\n  currentPage: number | undefined;       // Current page\n  pageSize: number | undefined;          // Items per page\n}\n\nclass Api {\n  #baseURL = \"http://localhost:3000\";\n  #categoriesCache: Category[] | null = null;\n\n  async #fetch(path: string, options?: RequestInit): Promise<any> {\n    const response = await fetch(this.#baseURL + path, options);\n    if (!response.ok) {\n      const text = await response.text();\n      throw new Error(`HTTP error ${response.status}: ${text}`);\n    }\n    return await response.json();\n  }\n\n  getAllCategories = async (): Promise<Category[]> => {\n    if (!this.#categoriesCache) {\n      const categories = await this.#fetch(\"/categories\");\n      this.#categoriesCache = Array.isArray(categories) ? categories : [];\n    }\n    return this.#categoriesCache;\n  };\n\n  createTransaction = (transaction: Transaction): Promise<Transaction> => {\n    this.#categoriesCache = null;\n    return this.#fetch(\"/transactions\", {\n      method: \"POST\",\n      body: JSON.stringify(transaction),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n  };\n\n  deleteTransaction = (id: number | string): Promise<void> =>\n    this.#fetch(`/transactions/${id}`, { method: \"DELETE\" });\n\n  updateTransaction = (\n    id: number | string,\n    updates: Partial<Transaction>\n  ): Promise<Transaction> =>\n    this.#fetch(`/transactions/${id}`, {\n      method: \"PATCH\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(updates),\n    });\n\n  getTransactionById = async (id: string | number): Promise<Transaction> => {\n    const response = await fetch(`${this.#baseURL}/transactions/${id}`);\n    if (!response.ok) {\n      if (response.status === 404) {\n        throw new Error(`Transaction with id ${id} not found`);\n      }\n      const text = await response.text();\n      throw new Error(`HTTP error ${response.status}: ${text}`);\n    }\n    return await response.json();\n  };\n\n\n  // async getTransactions(params: Params = {}): Promise<PaginatedTransactions> {\n  //   const {\n  //     page = 1,\n  //     limit, // optional\n  //     filters = {},\n  //     sort = { field: \"\", direction: \"desc\" },\n  //   } = params;\n  \n  //   const query = new URLSearchParams({\n  //     _page: page.toString(),\n  //     ...filters,\n  //   });\n  \n  //   if (limit) {\n  //     query.set(\"_per_page\", limit.toString());\n  //   }\n  \n  //   if (sort.field) {\n  //     query.set(\n  //       \"_sort\",\n  //       sort.direction === \"desc\" ? `-${sort.field}` : sort.field\n  //     );\n  //   }\n  \n  //   const response = await this.#fetch(`/transactions?${query.toString()}`);\n  \n  //   const totalItems = response.items;\n  //   const totalPages = limit ? Math.ceil(totalItems / limit) : 1;\n  \n  //   return {\n  //     data: response.data,\n  //     pages: totalPages,\n  //     items: totalItems,\n  //     currentPage: page,\n  //     pageSize: limit ?? totalItems, // if no limit, treat as \"all\"\n  //   };\n  // }\n  \n\n  async getTransactions(params: Params = {}): Promise<PaginatedTransactions> {\n    const {\n      page = 1,\n      limit = 10000, // Default to 1000 if no limit provided\n      filters = {},\n      sort = { field: \"\", direction: \"desc\" },\n    } = params;\n  \n    const query = new URLSearchParams({\n      _page: page.toString(),\n      _per_page: limit.toString(), // Always set limit - never omit\n      ...filters,\n    });\n  \n    if (sort.field) {\n      query.set(\n        \"_sort\",\n        sort.direction === \"desc\" ? `-${sort.field}` : sort.field\n      );\n    }\n  \n    const response = await this.#fetch(`/transactions?${query.toString()}`);\n  \n    // Handle both paginated and non-paginated responses from json-server\n    const data = Array.isArray(response) ? response : (response.data || response || []);\n    const totalItems = response.items || response.length || data.length || 0;\n    const totalPages = Math.ceil(totalItems / limit);\n  \n    return {\n      data,\n      pages: totalPages,\n      items: totalItems,\n      currentPage: page,\n      pageSize: limit,\n    };\n  }\n}\n\nexport default Api;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///Users/vitaliylevdansky/Documents/GitHub/NextFinanceApp/app/contexts/TransactionContext.tsx"],"sourcesContent":["\"use client\";\n\nimport {\n  createContext,\n  useContext,\n  useState,\n  useEffect,\n  ReactNode,\n  useCallback,\n} from \"react\";\nimport Api from \"../services/logic\";\nimport { Transaction, Category, SortOptions } from \"../services/logic\";\n\ninterface TransactionContextType {\n  transactions: Transaction[];\n  categories: Category[];\n  loading: boolean;\n  refreshData: () => Promise<void>;\n  addTransaction: (transaction: Transaction) => void;\n\n  tableData: {\n    transactions: Transaction[];\n    totalPages: number;\n    totalItems: number;\n    loading: boolean;\n  };\n  fetchTableData: (options: {\n    page: number;\n    limit: number;\n    sort?: SortOptions;\n    filters?: { category?: string; type?: string; description?: string };\n  }) => Promise<void>;\n\n  deleteTransaction: (id: number) => Promise<void>;\n  currentTableOptions: {\n    page: number;\n    limit: number;\n    sort?: SortOptions;\n    filters?: { category?: string; type?: string; description?: string };\n  };\n}\n\nconst TransactionContext = createContext<TransactionContextType | undefined>(\n  undefined\n);\n\nconst api = new Api();\n\nconst STORAGE_KEYS = {\n  TABLE_OPTIONS: \"transactions_table_options\",\n};\n\nconst DEFAULT_OPTIONS = {\n  page: 1,\n  limit: 10,\n  sort: { field: \"date\", direction: \"desc\" } as SortOptions,\n  filters: {} as { category?: string; type?: string; description?: string },\n};\n\nexport function TransactionProvider({ children }: { children: ReactNode }) {\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\n  const [categories, setCategories] = useState<Category[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const [tableTransactions, setTableTransactions] = useState<Transaction[]>([]);\n  const [tableTotalPages, setTableTotalPages] = useState(1);\n  const [tableTotalItems, setTableTotalItems] = useState(0);\n  const [tableLoading, setTableLoading] = useState(false);\n\n  const [currentTableOptions, setCurrentTableOptions] = useState<{\n    page: number;\n    limit: number;\n    sort?: SortOptions;\n    filters?: { category?: string; type?: string; description?: string };\n  }>(DEFAULT_OPTIONS);\n\n  const [initialLoadDone, setInitialLoadDone] = useState(false);\n\n  useEffect(() => {\n    const loadSavedOptions = () => {\n      try {\n        const saved = localStorage.getItem(STORAGE_KEYS.TABLE_OPTIONS);\n        if (saved) {\n          const parsed = JSON.parse(saved);\n\n          if (parsed && typeof parsed === \"object\") {\n            return {\n              page: Number(parsed.page) || DEFAULT_OPTIONS.page,\n              limit: Number(parsed.limit) || DEFAULT_OPTIONS.limit,\n              sort: parsed.sort || DEFAULT_OPTIONS.sort,\n              filters: parsed.filters || DEFAULT_OPTIONS.filters,\n            };\n          }\n        }\n      } catch (error) {\n        console.error(\"Error loading saved table options:\", error);\n      }\n      return DEFAULT_OPTIONS;\n    };\n\n    const savedOptions = loadSavedOptions();\n    setCurrentTableOptions(savedOptions);\n    setInitialLoadDone(true);\n  }, []);\n\n  useEffect(() => {\n    if (initialLoadDone) {\n      try {\n        localStorage.setItem(\n          STORAGE_KEYS.TABLE_OPTIONS,\n          JSON.stringify(currentTableOptions)\n        );\n      } catch (error) {\n        console.error(\"Error saving table options:\", error);\n      }\n    }\n  }, [currentTableOptions, initialLoadDone]);\n\n  useEffect(() => {\n    if (initialLoadDone) {\n      fetchTableData(currentTableOptions);\n      fetchAllData();\n    }\n  }, [initialLoadDone]);\n\n  const fetchAllData = async () => {\n    setLoading(true);\n    try {\n      const [transactionsResult, categoriesResult] = await Promise.all([\n        api.getTransactions({\n          page: 1,\n          sort: { field: \"date\", direction: \"desc\" },\n        }),\n        api.getAllCategories(),\n      ]);\n\n      setTransactions(transactionsResult.data || []);\n\n      if (Array.isArray(categoriesResult)) {\n        setCategories(categoriesResult);\n      } else {\n        setCategories([]);\n      }\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const fetchTableData = useCallback(\n    async (options: {\n      page: number;\n      limit: number;\n      sort?: SortOptions;\n      filters?: { category?: string; type?: string; description?: string };\n    }) => {\n      setTableLoading(true);\n      try {\n        const result = await api.getTransactions({\n          page: options.page,\n          limit: options.limit,\n          sort: options.sort?.field\n            ? {\n                field: options.sort.field,\n                direction: options.sort.direction || \"desc\",\n              }\n            : { field: \"date\", direction: \"desc\" },\n          filters: options.filters,\n        });\n\n        setTableTransactions(result.data || []);\n        setTableTotalPages(result.pages || 1);\n        setTableTotalItems(result.items || 0);\n\n        setCurrentTableOptions((prev) => {\n          if (JSON.stringify(prev) === JSON.stringify(options)) {\n            return prev;\n          }\n          return options;\n        });\n      } catch (error) {\n        console.error(\"Error fetching table data:\", error);\n        setTableTransactions([]);\n        setTableTotalPages(1);\n        setTableTotalItems(0);\n      } finally {\n        setTableLoading(false);\n      }\n    },\n    []\n  );\n\n  const refreshData = async () => {\n    await fetchAllData();\n    await fetchTableData(currentTableOptions);\n  };\n\n  const addTransaction = async (transaction: Transaction) => {\n    setTransactions((prev) => [transaction, ...prev]);\n    await fetchAllData();\n    await fetchTableData(currentTableOptions);\n  };\n\n  const deleteTransaction = async (id: number) => {\n    try {\n      await api.deleteTransaction(id);\n\n      setTransactions((prev) => prev.filter((t) => t.id !== id));\n      setTableTransactions((prev) => prev.filter((t) => t.id !== id));\n      setTableTotalItems((prev) => Math.max(0, prev - 1));\n\n      if (tableTransactions.length === 1 && currentTableOptions.page > 1) {\n        const newPage = currentTableOptions.page - 1;\n        const newOptions = { ...currentTableOptions, page: newPage };\n        fetchTableData(newOptions);\n      } else {\n        fetchTableData(currentTableOptions);\n      }\n    } catch (error) {\n      console.error(\"Error deleting transaction:\", error);\n      fetchTableData(currentTableOptions);\n      throw error;\n    }\n  };\n\n  return (\n    <TransactionContext.Provider\n      value={{\n        transactions,\n        categories,\n        loading,\n        refreshData,\n        addTransaction,\n\n        tableData: {\n          transactions: tableTransactions,\n          totalPages: tableTotalPages,\n          totalItems: tableTotalItems,\n          loading: tableLoading,\n        },\n        fetchTableData,\n        deleteTransaction,\n        currentTableOptions,\n      }}\n    >\n      {children}\n    </TransactionContext.Provider>\n  );\n}\n\nexport function useTransactions() {\n  const context = useContext(TransactionContext);\n  if (context === undefined) {\n    throw new Error(\n      \"useTransactions must be used within a TransactionProvider\"\n    );\n  }\n  return context;\n}\n"],"names":[],"mappings":"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"}}]
}