{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///D:/System/SamsungPortableSSD_SW/NextFinanceApp/app/services/logic.ts"],"sourcesContent":["\n// export type Transaction = {\n//   id?: string | number;\n//   amount: number;\n//   date: string;\n//   category: string;\n//   description: string;\n//   type: \"expense\" | \"income\" | string;\n// };\n\n// export type SortOptions = {\n//   field: string | null;\n//   direction: \"desc\" | \"asc\" | null;\n// };\n\n// interface Params {\n//   page?: number;\n//   limit?: number;\n//   filters?: Record<string, any>;\n//   sort?: SortOptions;\n// }\n\n// export type Category = {\n//   id: string | number;\n//   name: string;\n// };\n\n// class Api {\n//   #baseURL = \"http://localhost:3000\";\n  \n \n//   #categoriesCache: Category[] | null = null;\n\n//   /**\n//    * Internal fetch wrapper that handles errors consistently\n//    * \n//    * @param path - API endpoint path (e.g., \"/transactions\" or \"/categories\")\n//    * @param options - Standard fetch options (method, body, headers, etc.)\n//    * @returns Parsed JSON response\n//    * @throws Error if HTTP response is not ok (status >= 400)\n//    */\n//   async #fetch(path: string, options?: RequestInit): Promise<any> {\n    \n//     const response = await fetch(this.#baseURL + path, options);\n    \n//     if (!response.ok) {\n      \n//       const text = await response.text();\n//       throw new Error(`HTTP error ${response.status}: ${text}`);\n//     }\n\n//     return await response.json();\n//   }\n\n  \n//   getAllCategories = async (): Promise<Category[]> => {\n    \n//     if (!this.#categoriesCache) {\n//       const categories = await this.#fetch(\"/categories\");\n//       this.#categoriesCache = Array.isArray(categories) ? categories : [];\n//     }\n//     return this.#categoriesCache;\n//   };\n\n  \n//   createTransaction = (transaction: Transaction): Promise<Transaction> => {\n\n//     this.#categoriesCache = null;\n    \n//     return this.#fetch(\"/transactions\", {\n//       method: \"POST\",\n//       body: JSON.stringify(transaction),\n//       headers: {\n//         \"Content-Type\": \"application/json\",\n//       },\n//     });\n//   };\n\n\n//   deleteTransaction = (id: number | string): Promise<void> =>\n//     this.#fetch(`/transactions/${id}`, { method: \"DELETE\" });\n\n \n//   updateTransaction = (\n//     id: number | string,\n//     updates: Partial<Transaction>\n//   ): Promise<Transaction> =>\n//     this.#fetch(`/transactions/${id}`, {\n//       method: \"PATCH\",\n//       headers: {\n//         \"Content-Type\": \"application/json\",\n//       },\n//       body: JSON.stringify(updates),\n//     });\n\n \n//   getTransactionById = async (id: string | number): Promise<Transaction> => {\n//     const response = await fetch(`${this.#baseURL}/transactions/${id}`);\n\n//     if (!response.ok) {\n//       // Provide user-friendly error for 404\n//       if (response.status === 404) {\n//         throw new Error(`Transaction with id ${id} not found`);\n//       }\n//       const text = await response.text();\n//       throw new Error(`HTTP error ${response.status}: ${text}`);\n//     }\n\n//     return await response.json();\n//   };\n\n  \n//   async getTransactions(params: Params = {}): Promise<Transaction> {\n    \n//     const {\n//       page = 1,\n//       limit = 10,\n//       filters = {},\n//       sort = { field: \"\", direction: \"desc\" },\n//     } = params;\n    \n    \n//     const query = new URLSearchParams({\n//       _page: page.toString(),\n//       _per_page: limit.toString(),\n//       ...filters, // Spread filters as query params (e.g., { category: \"5\" } → ?category=5)\n//     });\n\n   \n//     if (sort.field) {\n//       query.set(\n//         \"_sort\",\n//         sort.direction === \"desc\" ? `-${sort.field}` : sort.field\n//       );\n//     }\n\n//     const result = await this.#fetch(`/transactions?${query.toString()}`);\n//     return { ...result, currentPage: page };\n//   }\n// }\n\n// export default Api;\n\n\nexport type Transaction = {\n  id?: string | number | undefined;\n  amount: number;\n  date: string;\n  category: string;\n  description: string;\n  type: \"expense\" | \"income\" | string;\n};\n\nexport type SortOptions = {\n  field: string | null;\n  direction: \"desc\" | \"asc\" | null;\n};\n\nexport type Category = {\n  id: string | number;\n  name: string;\n};\n\ninterface Params {\n  page?: number | undefined;\n  limit?: number | undefined;\n  filters?: Record<string, any>;\n  sort?: SortOptions;\n}\n\n\nexport interface PaginatedTransactions {\n  data: Transaction[];       \n  pages: number | undefined;             // Total pages\n  items: number | undefined;             // Total items count\n  currentPage: number | undefined;       // Current page\n  pageSize: number | undefined;          // Items per page\n}\n\nclass Api {\n  // URL бэкенда: берём из env или fallback на localhost для локальной разработки\n  #baseURL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3000\";\n  #categoriesCache: Category[] | null = null;\n\n  async #fetch(path: string, options?: RequestInit): Promise<any> {\n    const response = await fetch(this.#baseURL + path, options);\n    if (!response.ok) {\n      const text = await response.text();\n      throw new Error(`HTTP error ${response.status}: ${text}`);\n    }\n    return await response.json();\n  }\n\n  getAllCategories = async (): Promise<Category[]> => {\n    if (!this.#categoriesCache) {\n      const categories = await this.#fetch(\"/categories\");\n      this.#categoriesCache = Array.isArray(categories) ? categories : [];\n    }\n    return this.#categoriesCache;\n  };\n\n  createTransaction = (transaction: Transaction): Promise<Transaction> => {\n    this.#categoriesCache = null;\n    return this.#fetch(\"/transactions\", {\n      method: \"POST\",\n      body: JSON.stringify(transaction),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n  };\n\n  deleteTransaction = (id: number | string): Promise<void> =>\n    this.#fetch(`/transactions/${id}`, { method: \"DELETE\" });\n\n  updateTransaction = (\n    id: number | string,\n    updates: Partial<Transaction>\n  ): Promise<Transaction> =>\n    this.#fetch(`/transactions/${id}`, {\n      method: \"PATCH\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(updates),\n    });\n\n  getTransactionById = async (id: string | number): Promise<Transaction> => {\n    return this.#fetch(`/transactions/${id}`);\n  };\n\n\n  // async getTransactions(params: Params = {}): Promise<PaginatedTransactions> {\n  //   const {\n  //     page = 1,\n  //     limit, // optional\n  //     filters = {},\n  //     sort = { field: \"\", direction: \"desc\" },\n  //   } = params;\n  \n  //   const query = new URLSearchParams({\n  //     _page: page.toString(),\n  //     ...filters,\n  //   });\n  \n  //   if (limit) {\n  //     query.set(\"_per_page\", limit.toString());\n  //   }\n  \n  //   if (sort.field) {\n  //     query.set(\n  //       \"_sort\",\n  //       sort.direction === \"desc\" ? `-${sort.field}` : sort.field\n  //     );\n  //   }\n  \n  //   const response = await this.#fetch(`/transactions?${query.toString()}`);\n  \n  //   const totalItems = response.items;\n  //   const totalPages = limit ? Math.ceil(totalItems / limit) : 1;\n  \n  //   return {\n  //     data: response.data,\n  //     pages: totalPages,\n  //     items: totalItems,\n  //     currentPage: page,\n  //     pageSize: limit ?? totalItems, // if no limit, treat as \"all\"\n  //   };\n  // }\n  \n\n  async getTransactions(params: Params = {}): Promise<PaginatedTransactions> {\n    const {\n      page = 1,\n      limit = 10000,\n      filters = {},\n      sort = { field: \"\", direction: \"desc\" },\n    } = params;\n\n    // Формируем query params для нашего Express API\n    const query = new URLSearchParams({\n      page: page.toString(),\n      limit: limit.toString(),\n      ...filters,\n    });\n\n    // Сортировка\n    if (sort.field) {\n      query.set(\"sort_by\", sort.field);\n      query.set(\"sort_order\", sort.direction || \"desc\");\n    }\n\n    const response = await this.#fetch(`/transactions?${query.toString()}`);\n\n    // API возвращает { data, items, pages, currentPage, pageSize }\n    return {\n      data: response.data || [],\n      pages: response.pages,\n      items: response.items,\n      currentPage: response.currentPage,\n      pageSize: response.pageSize,\n    };\n  }\n}\n\nexport default Api;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///D:/System/SamsungPortableSSD_SW/NextFinanceApp/app/contexts/TransactionContext.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useEffect,\r\n  ReactNode,\r\n  useCallback,\r\n} from \"react\";\r\nimport Api from \"../services/logic\";\r\nimport { Transaction, Category, SortOptions } from \"../services/logic\";\r\n\r\ninterface TransactionContextType {\r\n  transactions: Transaction[];\r\n  categories: Category[];\r\n  loading: boolean;\r\n  refreshData: () => Promise<void>;\r\n  addTransaction: (transaction: Transaction) => void;\r\n\r\n  tableData: {\r\n    transactions: Transaction[];\r\n    totalPages: number;\r\n    totalItems: number;\r\n    loading: boolean;\r\n  };\r\n  fetchTableData: (options: {\r\n    page: number;\r\n    limit: number;\r\n    sort?: SortOptions;\r\n    filters?: { category?: string; type?: string; description?: string };\r\n  }) => Promise<void>;\r\n\r\n  deleteTransaction: (id: number) => Promise<void>;\r\n  currentTableOptions: {\r\n    page: number;\r\n    limit: number;\r\n    sort?: SortOptions;\r\n    filters?: { category?: string; type?: string; description?: string };\r\n  };\r\n}\r\n\r\nconst TransactionContext = createContext<TransactionContextType | undefined>(\r\n  undefined\r\n);\r\n\r\nconst api = new Api();\r\n\r\nconst STORAGE_KEYS = {\r\n  TABLE_OPTIONS: \"transactions_table_options\",\r\n};\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  page: 1,\r\n  limit: 10,\r\n  sort: { field: \"date\", direction: \"desc\" } as SortOptions,\r\n  filters: {} as { category?: string; type?: string; description?: string },\r\n};\r\n\r\nexport function TransactionProvider({ children }: { children: ReactNode }) {\r\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\r\n  const [categories, setCategories] = useState<Category[]>([]);\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  const [tableTransactions, setTableTransactions] = useState<Transaction[]>([]);\r\n  const [tableTotalPages, setTableTotalPages] = useState(1);\r\n  const [tableTotalItems, setTableTotalItems] = useState(0);\r\n  const [tableLoading, setTableLoading] = useState(false);\r\n\r\n  const [currentTableOptions, setCurrentTableOptions] = useState<{\r\n    page: number;\r\n    limit: number;\r\n    sort?: SortOptions;\r\n    filters?: { category?: string; type?: string; description?: string };\r\n  }>(DEFAULT_OPTIONS);\r\n\r\n  const [initialLoadDone, setInitialLoadDone] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const loadSavedOptions = () => {\r\n      try {\r\n        const saved = localStorage.getItem(STORAGE_KEYS.TABLE_OPTIONS);\r\n        if (saved) {\r\n          const parsed = JSON.parse(saved);\r\n\r\n          if (parsed && typeof parsed === \"object\") {\r\n            return {\r\n              page: Number(parsed.page) || DEFAULT_OPTIONS.page,\r\n              limit: Number(parsed.limit) || DEFAULT_OPTIONS.limit,\r\n              sort: parsed.sort || DEFAULT_OPTIONS.sort,\r\n              filters: parsed.filters || DEFAULT_OPTIONS.filters,\r\n            };\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error loading saved table options:\", error);\r\n      }\r\n      return DEFAULT_OPTIONS;\r\n    };\r\n\r\n    const savedOptions = loadSavedOptions();\r\n    setCurrentTableOptions(savedOptions);\r\n    setInitialLoadDone(true);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (initialLoadDone) {\r\n      try {\r\n        localStorage.setItem(\r\n          STORAGE_KEYS.TABLE_OPTIONS,\r\n          JSON.stringify(currentTableOptions)\r\n        );\r\n      } catch (error) {\r\n        console.error(\"Error saving table options:\", error);\r\n      }\r\n    }\r\n  }, [currentTableOptions, initialLoadDone]);\r\n\r\n  useEffect(() => {\r\n    if (initialLoadDone) {\r\n      fetchTableData(currentTableOptions);\r\n      fetchAllData();\r\n    }\r\n  }, [initialLoadDone]);\r\n\r\n  const fetchAllData = async () => {\r\n    setLoading(true);\r\n    try {\r\n      const [transactionsResult, categoriesResult] = await Promise.all([\r\n        api.getTransactions({\r\n          page: 1,\r\n          sort: { field: \"date\", direction: \"desc\" },\r\n        }),\r\n        api.getAllCategories(),\r\n      ]);\r\n\r\n      setTransactions(transactionsResult.data || []);\r\n\r\n      if (Array.isArray(categoriesResult)) {\r\n        setCategories(categoriesResult);\r\n      } else {\r\n        setCategories([]);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error fetching data:\", error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const fetchTableData = useCallback(\r\n    async (options: {\r\n      page: number;\r\n      limit: number;\r\n      sort?: SortOptions;\r\n      filters?: { category?: string; type?: string; description?: string };\r\n    }) => {\r\n      setTableLoading(true);\r\n      try {\r\n        const result = await api.getTransactions({\r\n          page: options.page,\r\n          limit: options.limit,\r\n          sort: options.sort?.field\r\n            ? {\r\n                field: options.sort.field,\r\n                direction: options.sort.direction || \"desc\",\r\n              }\r\n            : { field: \"date\", direction: \"desc\" },\r\n          filters: options.filters,\r\n        });\r\n\r\n        setTableTransactions(result.data || []);\r\n        setTableTotalPages(result.pages || 1);\r\n        setTableTotalItems(result.items || 0);\r\n\r\n        setCurrentTableOptions((prev) => {\r\n          if (JSON.stringify(prev) === JSON.stringify(options)) {\r\n            return prev;\r\n          }\r\n          return options;\r\n        });\r\n      } catch (error) {\r\n        console.error(\"Error fetching table data:\", error);\r\n        setTableTransactions([]);\r\n        setTableTotalPages(1);\r\n        setTableTotalItems(0);\r\n      } finally {\r\n        setTableLoading(false);\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  const refreshData = async () => {\r\n    await fetchAllData();\r\n    await fetchTableData(currentTableOptions);\r\n  };\r\n\r\n  const addTransaction = async (transaction: Transaction) => {\r\n    setTransactions((prev) => [transaction, ...prev]);\r\n    await fetchAllData();\r\n    await fetchTableData(currentTableOptions);\r\n  };\r\n\r\n  const deleteTransaction = async (id: number) => {\r\n    try {\r\n      await api.deleteTransaction(id);\r\n\r\n      setTransactions((prev) => prev.filter((t) => t.id !== id));\r\n      setTableTransactions((prev) => prev.filter((t) => t.id !== id));\r\n      setTableTotalItems((prev) => Math.max(0, prev - 1));\r\n\r\n      if (tableTransactions.length === 1 && currentTableOptions.page > 1) {\r\n        const newPage = currentTableOptions.page - 1;\r\n        const newOptions = { ...currentTableOptions, page: newPage };\r\n        fetchTableData(newOptions);\r\n      } else {\r\n        fetchTableData(currentTableOptions);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error deleting transaction:\", error);\r\n      fetchTableData(currentTableOptions);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <TransactionContext.Provider\r\n      value={{\r\n        transactions,\r\n        categories,\r\n        loading,\r\n        refreshData,\r\n        addTransaction,\r\n\r\n        tableData: {\r\n          transactions: tableTransactions,\r\n          totalPages: tableTotalPages,\r\n          totalItems: tableTotalItems,\r\n          loading: tableLoading,\r\n        },\r\n        fetchTableData,\r\n        deleteTransaction,\r\n        currentTableOptions,\r\n      }}\r\n    >\r\n      {children}\r\n    </TransactionContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useTransactions() {\r\n  const context = useContext(TransactionContext);\r\n  if (context === undefined) {\r\n    throw new Error(\r\n      \"useTransactions must be used within a TransactionProvider\"\r\n    );\r\n  }\r\n  return context;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"sources":["file:///D:/System/SamsungPortableSSD_SW/NextFinanceApp/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;KAElC;IACL,IAAIF,QAAQC,GAAG,CAACK,yBAAyB,EAAE;;SAcpC;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;QAGT,OAAO;;IAOT;AACF","ignoreList":[0]}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///D:/System/SamsungPortableSSD_SW/NextFinanceApp/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,4HACRC,QAAQ,CAAC,YAAY,CAAEC,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///D:/System/SamsungPortableSSD_SW/NextFinanceApp/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n"],"names":["module","exports","require","vendored","React"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,4HACRC,QAAQ,CAAC,YAAY,CAAEC,KAAK","ignoreList":[0]}}]
}