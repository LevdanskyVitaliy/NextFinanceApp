{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/vitaliylevdansky/Documents/GitHub/NextFinanceApp/app/transactions/route.ts"],"sourcesContent":["/**\n * app/transactions/route.ts\n * \n * This file implements the Next.js API route handlers for the `/transactions` endpoint.\n * It handles GET (list transactions) and POST (create transaction) requests.\n * \n * ARCHITECTURE:\n * - This is a Next.js App Router route handler (not Pages Router)\n * - File-based routing: `app/transactions/route.ts` automatically creates `/transactions` endpoint\n * - Server-side only: Runs on Node.js server, never sent to browser\n * - Reads/writes to `server/db.json` as a simple file-based database\n * \n * HOW IT WORKS:\n * 1. Client calls `fetch(\"/transactions\")` from browser or server component\n * 2. Next.js routes request to this file's exported functions (GET/POST)\n * 3. Functions read/write JSON file synchronously\n * 4. Returns JSON response that client can consume\n * \n * IMPORTANT LIMITATIONS:\n * - File writes work locally but NOT persisted on Vercel (serverless filesystem is read-only)\n * - No concurrent write protection (multiple requests could corrupt data)\n * - For production, replace with real database (PostgreSQL, MongoDB, etc.)\n */\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\n// Transaction type matching the structure in db.json\ntype Transaction = {\n  id: string;\n  amount: number;\n  date: string;\n  category: string;\n  description: string;\n  type: string;\n};\n\n// Shape of the entire database file\ntype DbShape = {\n  transactions: Transaction[];\n  categories: { id: string; name: string }[];\n};\n\n// Path to the database file relative to project root\n// process.cwd() = project root directory\nconst DB_PATH = path.join(process.cwd(), \"server\", \"db.json\");\n\n/**\n * Reads the entire database file from disk and parses JSON\n * @returns Promise resolving to the database object\n */\nasync function readDb(): Promise<DbShape> {\n  const file = await fs.readFile(DB_PATH, \"utf-8\");\n  return JSON.parse(file) as DbShape;\n}\n\n/**\n * Writes the database object back to disk as formatted JSON\n * @param data - The complete database object to write\n */\nasync function writeDb(data: DbShape) {\n  await fs.writeFile(DB_PATH, JSON.stringify(data, null, 2), \"utf-8\");\n}\n\n/**\n * GET /transactions\n * \n * Handles listing transactions with pagination, filtering, and sorting.\n * \n * QUERY PARAMETERS:\n * - _page: Page number (default: 1)\n * - _per_page: Items per page (default: 10)\n * - _sort: Sort field, prefix with \"-\" for descending (e.g., \"-date\" or \"amount\")\n * - Any other params: Treated as filters (e.g., ?category=5&type=expense)\n * \n * RESPONSE FORMAT:\n * {\n *   data: Transaction[],      // Array of transactions for current page\n *   items: number,            // Total number of items (after filtering)\n *   pages: number             // Total number of pages\n * }\n * \n * EXAMPLE REQUESTS:\n * - GET /transactions?_page=1&_per_page=10&_sort=-date\n * - GET /transactions?category=5&type=expense&_page=1\n */\nexport async function GET(request: NextRequest) {\n  // Extract query parameters from URL\n  const { searchParams } = new URL(request.url);\n\n  // Parse pagination parameters with defaults\n  const page = Number(searchParams.get(\"_page\") ?? \"1\") || 1;\n  const limit = Number(searchParams.get(\"_per_page\") ?? \"10\") || 10;\n  const sortParam = searchParams.get(\"_sort\");\n\n  // Extract filter parameters (everything except pagination/sort params)\n  // This allows flexible filtering: ?category=5&type=expense&description=test\n  const filters: Record<string, string> = {};\n  searchParams.forEach((value, key) => {\n    if (![\"_page\", \"_per_page\", \"_sort\"].includes(key)) {\n      filters[key] = value;\n    }\n  });\n\n  // Load database from disk\n  const db = await readDb();\n  // Create a copy to avoid mutating original array\n  let data = db.transactions.slice();\n\n  // Apply filters: match transaction fields to filter values\n  // Example: filter by category=\"5\" will match transactions where tx.category === \"5\"\n  Object.entries(filters).forEach(([key, value]) => {\n    if (!value) return; // Skip empty filters\n    data = data.filter((tx) => String((tx as any)[key]) === String(value));\n  });\n\n  // Apply sorting if requested\n  // Sort format: \"-date\" means descending by date, \"amount\" means ascending by amount\n  if (sortParam) {\n    const desc = sortParam.startsWith(\"-\");\n    const field = desc ? sortParam.slice(1) : sortParam;\n    data.sort((a: any, b: any) => {\n      const av = a[field];\n      const bv = b[field];\n      if (av === bv) return 0;\n      // Null/undefined values go to end\n      if (av == null) return 1;\n      if (bv == null) return -1;\n      // Compare values (works for strings, numbers, dates)\n      if (av < bv) return desc ? 1 : -1;\n      return desc ? -1 : 1;\n    });\n  }\n\n  // Calculate pagination metadata\n  const totalItems = data.length;\n  const totalPages = Math.max(1, Math.ceil(totalItems / limit));\n  const start = (page - 1) * limit;\n  const end = start + limit;\n  const pageData = data.slice(start, end);\n\n  // Return paginated results with metadata\n  return NextResponse.json({\n    data: pageData,\n    items: totalItems,\n    pages: totalPages,\n  });\n}\n\n/**\n * POST /transactions\n * \n * Creates a new transaction and adds it to the database.\n * \n * REQUEST BODY:\n * {\n *   id?: string,              // Optional - auto-generated if not provided\n *   amount: number,            // Required\n *   date: string,             // Required (ISO date string)\n *   category: string,         // Required (can be empty string)\n *   description?: string,      // Optional (defaults to empty string)\n *   type: \"expense\" | \"income\" // Required\n * }\n * \n * RESPONSE:\n * - 201 Created: Returns the created transaction object\n * - 400 Bad Request: Returns error message if validation fails\n * \n * BEHAVIOR:\n * - New transaction is added to the BEGINNING of the array (unshift)\n * - This makes newest transactions appear first when sorted by date\n * - ID is auto-generated if not provided (4-character hex string)\n */\nexport async function POST(request: NextRequest) {\n  // Parse JSON body from request\n  const body = (await request.json()) as Partial<Transaction>;\n\n  // Validate required fields\n  // Note: category can be empty string, so we check for undefined, not falsy\n  if (\n    typeof body.amount !== \"number\" ||\n    !body.date ||\n    body.category === undefined ||\n    !body.type\n  ) {\n    return NextResponse.json(\n      { error: \"Invalid transaction payload\" },\n      { status: 400 }\n    );\n  }\n\n  // Load current database state\n  const db = await readDb();\n\n  // Generate ID if not provided\n  // Format: 4-character hexadecimal string (e.g., \"a8d6\", \"2efb\")\n  // This matches the ID format used in your existing db.json\n  const id =\n    body.id && String(body.id).length\n      ? String(body.id)\n      : Math.random().toString(16).slice(2, 6);\n\n  // Create new transaction object with all fields\n  const newTx: Transaction = {\n    id,\n    amount: body.amount,\n    date: body.date,\n    category: String(body.category ?? \"\"), // Ensure category is always a string\n    description: body.description ?? \"\",   // Default to empty string if missing\n    type: body.type,\n  };\n\n  // Add to beginning of array (newest first)\n  db.transactions.unshift(newTx);\n  \n  // Persist changes to disk\n  await writeDb(db);\n\n  // Return created transaction with 201 Created status\n  return NextResponse.json(newTx, { status: 201 });\n}\n\n\n"],"names":[],"mappings":"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","debugId":null}}]
}