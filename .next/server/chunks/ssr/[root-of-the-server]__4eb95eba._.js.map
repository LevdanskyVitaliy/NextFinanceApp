{"version":3,"sources":["turbopack:///[project]/Documents/GitHub/NextFinanceApp/node_modules/next/src/server/route-modules/app-page/module.compiled.js","turbopack:///[project]/Documents/GitHub/NextFinanceApp/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","turbopack:///[project]/Documents/GitHub/NextFinanceApp/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","turbopack:///[project]/Documents/GitHub/NextFinanceApp/app/services/logic.ts","turbopack:///[project]/Documents/GitHub/NextFinanceApp/app/contexts/TransactionContext.tsx"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","export type Transaction = {\n  id?: string | number;\n  amount: number;\n  date: string;\n  category: string;\n  description: string;\n  type: \"expense\" | \"income\" | string;\n};\n\nexport type SortOptions = {\n  field: string | null;\n  direction: \"desc\" | \"asc\" | null;\n};\n\ninterface Params {\n  page?: number;\n  limit?: number;\n  filters?: Record<string, any>;\n  sort?: SortOptions;\n}\n\nexport type Category = {\n  id: string | number;\n  name: string;\n};\n\n/**\n * Api Class - HTTP Client for Transaction and Category Operations\n * \n * This class provides a clean interface for making API calls to your Next.js routes.\n * It abstracts away the fetch details and provides typed methods.\n * \n * KEY CHANGE FROM BEFORE:\n * - OLD: Hard-coded `http://localhost:3000` (only worked locally)\n * - NEW: Dynamic base URL that works in both dev and production\n * \n * HOW BASE URL WORKS:\n * - Server-side (SSR): `window` is undefined, so baseURL = \"\" (relative URLs)\n * - Client-side (browser): Uses `window.location.origin` (e.g., \"https://yourapp.vercel.app\")\n * - Result: Same code works locally AND on Vercel without changes!\n * \n * EXAMPLE:\n * - Local dev: fetch(\"http://localhost:3000/transactions\") → Next route handler\n * - Vercel: fetch(\"https://yourapp.vercel.app/transactions\") → Next route handler\n */\nclass Api {\n  // Old hard-coded approach (commented out for reference):\n  #baseURL = \"http://localhost:3000\";\n  \n  // New dynamic approach: works everywhere!\n  // - Server-side: \"\" (empty string = relative URL from server)\n  // - Client-side: window.location.origin (current domain)\n        // #baseURL =\n       //   typeof window === \"undefined\" ? \"\" : window.location.origin ?? \"\";\n  \n  // Cache for categories since they rarely change\n  // Prevents unnecessary API calls\n  #categoriesCache: Category[] | null = null;\n\n  /**\n   * Internal fetch wrapper that handles errors consistently\n   * \n   * @param path - API endpoint path (e.g., \"/transactions\" or \"/categories\")\n   * @param options - Standard fetch options (method, body, headers, etc.)\n   * @returns Parsed JSON response\n   * @throws Error if HTTP response is not ok (status >= 400)\n   */\n  async #fetch(path: string, options?: RequestInit): Promise<any> {\n    // Construct full URL: baseURL + path\n    // Examples:\n    // - Local: \"\" + \"/transactions\" = \"/transactions\" (relative)\n    // - Vercel: \"https://app.vercel.app\" + \"/transactions\" = \"https://app.vercel.app/transactions\"\n    const response = await fetch(this.#baseURL + path, options);\n    \n    if (!response.ok) {\n      // Extract error message from response body\n      const text = await response.text();\n      throw new Error(`HTTP error ${response.status}: ${text}`);\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Fetches all categories from the database\n   * Uses caching to avoid repeated API calls\n   * \n   * @returns Array of category objects\n   */\n  getAllCategories = async (): Promise<Category[]> => {\n    // Return cached categories if available\n    if (!this.#categoriesCache) {\n      const categories = await this.#fetch(\"/categories\");\n      // Ensure we always return an array, even if API returns unexpected format\n      this.#categoriesCache = Array.isArray(categories) ? categories : [];\n    }\n    return this.#categoriesCache;\n  };\n\n  /**\n   * Creates a new transaction\n   * \n   * @param transaction - Transaction object to create (id is optional, auto-generated)\n   * @returns The created transaction with assigned ID\n   */\n  createTransaction = (transaction: Transaction): Promise<Transaction> => {\n    // Clear categories cache when creating transaction\n    // (In case categories change, though they shouldn't in this app)\n    this.#categoriesCache = null;\n    \n    return this.#fetch(\"/transactions\", {\n      method: \"POST\",\n      body: JSON.stringify(transaction),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n  };\n\n  /**\n   * Deletes a transaction by ID\n   * \n   * @param id - Transaction ID to delete\n   * @throws Error if transaction not found (404)\n   */\n  deleteTransaction = (id: number | string): Promise<void> =>\n    this.#fetch(`/transactions/${id}`, { method: \"DELETE\" });\n\n  /**\n   * Updates a transaction (partial update - only provided fields are changed)\n   * \n   * @param id - Transaction ID to update\n   * @param updates - Partial transaction object with fields to update\n   * @returns The updated transaction object\n   * @throws Error if transaction not found (404)\n   */\n  updateTransaction = (\n    id: number | string,\n    updates: Partial<Transaction>\n  ): Promise<Transaction> =>\n    this.#fetch(`/transactions/${id}`, {\n      method: \"PATCH\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(updates),\n    });\n\n  /**\n   * Fetches a single transaction by ID\n   * \n   * Note: This method uses fetch directly instead of #fetch wrapper\n   * to provide a more specific error message for 404s\n   * \n   * @param id - Transaction ID to fetch\n   * @returns The transaction object\n   * @throws Error with specific message if transaction not found (404)\n   */\n  getTransactionById = async (id: string | number): Promise<Transaction> => {\n    const response = await fetch(`${this.#baseURL}/transactions/${id}`);\n\n    if (!response.ok) {\n      // Provide user-friendly error for 404\n      if (response.status === 404) {\n        throw new Error(`Transaction with id ${id} not found`);\n      }\n      const text = await response.text();\n      throw new Error(`HTTP error ${response.status}: ${text}`);\n    }\n\n    return await response.json();\n  };\n\n  /**\n   * Fetches paginated, filtered, and sorted list of transactions\n   * \n   * @param params - Query parameters object\n   * @param params.page - Page number (default: 1)\n   * @param params.limit - Items per page (default: 10)\n   * @param params.filters - Object with filter key-value pairs (e.g., { category: \"5\", type: \"expense\" })\n   * @param params.sort - Sort options { field: string, direction: \"asc\" | \"desc\" }\n   * @returns Object with paginated data: { data: Transaction[], items: number, pages: number, currentPage: number }\n   * \n   * EXAMPLE:\n   * ```ts\n   * await api.getTransactions({\n   *   page: 2,\n   *   limit: 20,\n   *   filters: { category: \"5\", type: \"expense\" },\n   *   sort: { field: \"date\", direction: \"desc\" }\n   * });\n   * ```\n   * \n   * This builds a query string like:\n   * \"/transactions?_page=2&_per_page=20&category=5&type=expense&_sort=-date\"\n   */\n  async getTransactions(params: Params = {}): Promise<Transaction> {\n    // Extract parameters with defaults\n    const {\n      page = 1,\n      limit = 10,\n      filters = {},\n      sort = { field: \"\", direction: \"desc\" },\n    } = params;\n    \n    // Build query string with pagination and filters\n    const query = new URLSearchParams({\n      _page: page.toString(),\n      _per_page: limit.toString(),\n      ...filters, // Spread filters as query params (e.g., { category: \"5\" } → ?category=5)\n    });\n\n    // Add sort parameter if field is specified\n    // Format: \"-date\" for descending, \"date\" for ascending\n    if (sort.field) {\n      query.set(\n        \"_sort\",\n        sort.direction === \"desc\" ? `-${sort.field}` : sort.field\n      );\n    }\n\n    // Make API call and add currentPage to response for convenience\n    const result = await this.#fetch(`/transactions?${query.toString()}`);\n    return { ...result, currentPage: page };\n  }\n}\n\nexport default Api;\n","\"use client\";\n\nimport {\n  createContext,\n  useContext,\n  useState,\n  useEffect,\n  ReactNode,\n  useCallback,\n} from \"react\";\nimport Api from \"../services/logic\";\nimport { Transaction, Category, SortOptions } from \"../services/logic\";\n\ninterface TransactionContextType {\n  transactions: Transaction[];\n  categories: Category[];\n  loading: boolean;\n  refreshData: () => Promise<void>;\n  addTransaction: (transaction: Transaction) => void;\n\n  tableData: {\n    transactions: Transaction[];\n    totalPages: number;\n    totalItems: number;\n    loading: boolean;\n  };\n  fetchTableData: (options: {\n    page: number;\n    limit: number;\n    sort?: SortOptions;\n    filters?: { category?: string; type?: string; description?: string };\n  }) => Promise<void>;\n\n  deleteTransaction: (id: number) => Promise<void>;\n  currentTableOptions: {\n    page: number;\n    limit: number;\n    sort?: SortOptions;\n    filters?: { category?: string; type?: string; description?: string };\n  };\n}\n\nconst TransactionContext = createContext<TransactionContextType | undefined>(\n  undefined\n);\n\nconst api = new Api();\n\nconst STORAGE_KEYS = {\n  TABLE_OPTIONS: \"transactions_table_options\",\n};\n\nconst DEFAULT_OPTIONS = {\n  page: 1,\n  limit: 10,\n  sort: { field: \"date\", direction: \"desc\" } as SortOptions,\n  filters: {} as { category?: string; type?: string; description?: string },\n};\n\nexport function TransactionProvider({ children }: { children: ReactNode }) {\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\n  const [categories, setCategories] = useState<Category[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const [tableTransactions, setTableTransactions] = useState<Transaction[]>([]);\n  const [tableTotalPages, setTableTotalPages] = useState(1);\n  const [tableTotalItems, setTableTotalItems] = useState(0);\n  const [tableLoading, setTableLoading] = useState(false);\n\n  const [currentTableOptions, setCurrentTableOptions] = useState<{\n    page: number;\n    limit: number;\n    sort?: SortOptions;\n    filters?: { category?: string; type?: string; description?: string };\n  }>(DEFAULT_OPTIONS);\n\n  const [initialLoadDone, setInitialLoadDone] = useState(false);\n\n  useEffect(() => {\n    const loadSavedOptions = () => {\n      try {\n        const saved = localStorage.getItem(STORAGE_KEYS.TABLE_OPTIONS);\n        if (saved) {\n          const parsed = JSON.parse(saved);\n\n          if (parsed && typeof parsed === \"object\") {\n            return {\n              page: Number(parsed.page) || DEFAULT_OPTIONS.page,\n              limit: Number(parsed.limit) || DEFAULT_OPTIONS.limit,\n              sort: parsed.sort || DEFAULT_OPTIONS.sort,\n              filters: parsed.filters || DEFAULT_OPTIONS.filters,\n            };\n          }\n        }\n      } catch (error) {\n        console.error(\"Error loading saved table options:\", error);\n      }\n      return DEFAULT_OPTIONS;\n    };\n\n    const savedOptions = loadSavedOptions();\n    setCurrentTableOptions(savedOptions);\n    setInitialLoadDone(true);\n  }, []);\n\n  useEffect(() => {\n    if (initialLoadDone) {\n      try {\n        localStorage.setItem(\n          STORAGE_KEYS.TABLE_OPTIONS,\n          JSON.stringify(currentTableOptions)\n        );\n      } catch (error) {\n        console.error(\"Error saving table options:\", error);\n      }\n    }\n  }, [currentTableOptions, initialLoadDone]);\n\n  useEffect(() => {\n    if (initialLoadDone) {\n      fetchTableData(currentTableOptions);\n      fetchAllData();\n    }\n  }, [initialLoadDone]);\n\n  const fetchAllData = async () => {\n    setLoading(true);\n    try {\n      const [transactionsResult, categoriesResult] = await Promise.all([\n        api.getTransactions({\n          page: 1,\n          limit: 10000,\n          sort: { field: \"date\", direction: \"desc\" },\n        }),\n        api.getAllCategories(),\n      ]);\n\n      setTransactions(transactionsResult.data || []);\n\n      if (Array.isArray(categoriesResult)) {\n        setCategories(categoriesResult);\n      } else {\n        setCategories([]);\n      }\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const fetchTableData = useCallback(\n    async (options: {\n      page: number;\n      limit: number;\n      sort?: SortOptions;\n      filters?: { category?: string; type?: string; description?: string };\n    }) => {\n      setTableLoading(true);\n      try {\n        const result = await api.getTransactions({\n          page: options.page,\n          limit: options.limit,\n          sort: options.sort?.field\n            ? {\n                field: options.sort.field,\n                direction: options.sort.direction || \"desc\",\n              }\n            : { field: \"date\", direction: \"desc\" },\n          filters: options.filters,\n        });\n\n        setTableTransactions(result.data || []);\n        setTableTotalPages(result.pages || 1);\n        setTableTotalItems(result.items || 0);\n\n        setCurrentTableOptions((prev) => {\n          if (JSON.stringify(prev) === JSON.stringify(options)) {\n            return prev;\n          }\n          return options;\n        });\n      } catch (error) {\n        console.error(\"Error fetching table data:\", error);\n        setTableTransactions([]);\n        setTableTotalPages(1);\n        setTableTotalItems(0);\n      } finally {\n        setTableLoading(false);\n      }\n    },\n    []\n  );\n\n  const refreshData = async () => {\n    await fetchAllData();\n    await fetchTableData(currentTableOptions);\n  };\n\n  const addTransaction = async (transaction: Transaction) => {\n    setTransactions((prev) => [transaction, ...prev]);\n    await fetchAllData();\n    await fetchTableData(currentTableOptions);\n  };\n\n  const deleteTransaction = async (id: number) => {\n    try {\n      await api.deleteTransaction(id);\n\n      setTransactions((prev) => prev.filter((t) => t.id !== id));\n      setTableTransactions((prev) => prev.filter((t) => t.id !== id));\n      setTableTotalItems((prev) => Math.max(0, prev - 1));\n\n      if (tableTransactions.length === 1 && currentTableOptions.page > 1) {\n        const newPage = currentTableOptions.page - 1;\n        const newOptions = { ...currentTableOptions, page: newPage };\n        fetchTableData(newOptions);\n      } else {\n        fetchTableData(currentTableOptions);\n      }\n    } catch (error) {\n      console.error(\"Error deleting transaction:\", error);\n      fetchTableData(currentTableOptions);\n      throw error;\n    }\n  };\n\n  return (\n    <TransactionContext.Provider\n      value={{\n        transactions,\n        categories,\n        loading,\n        refreshData,\n        addTransaction,\n\n        tableData: {\n          transactions: tableTransactions,\n          totalPages: tableTotalPages,\n          totalItems: tableTotalItems,\n          loading: tableLoading,\n        },\n        fetchTableData,\n        deleteTransaction,\n        currentTableOptions,\n      }}\n    >\n      {children}\n    </TransactionContext.Provider>\n  );\n}\n\nexport function useTransactions() {\n  const context = useContext(TransactionContext);\n  if (context === undefined) {\n    throw new Error(\n      \"useTransactions must be used within a TransactionProvider\"\n    );\n  }\n  return context;\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactJsxRuntime","React"],"mappings":"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","ignoreList":[0,1,2]}